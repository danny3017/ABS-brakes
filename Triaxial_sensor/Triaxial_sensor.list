				;file D:\IIIT\Documents\HTK_Project\Triaxial_sensor\SourceCode.c
				;1	#include <HT66F70A.h>
				;2	
				;3	#define	DATA_BUS _pg
				;4	#define RS  _ph0
				;5	#define RW  _ph1
				;6	#define EN  _ph2
				;7	
				;8	#define SDO _pa5	//以盛群為基準
				;9	#define SDA _pa6	//以盛群為基準
				;10	#define SCK _pa7
				;11	#define CS  _pb5
				;12	
				;13	#define SDOC _pac5	//以盛群為基準
				;14	#define SDAC _pac6
				;15	#define SCKC _pac7
				;16	#define CSC  _pbc5
				;17	
				;18	#define SDOPU _papu5	//盛群為基準
				;19	#define SDAPU _papu6
				;20	#define SCKPU _papu7
				;21	#define CSPU  _pbpu5
				;22	
				;23	#define PAS2 _pas2	//pas 5 SDO
				;24	#define PAS3 _pas3	//pas 6 7 SDI SCL
				;25	#define PBS2 _pbs2	//pbs5 scs
				;26	
				;27	void Delay100us(short);	
				;28	void _SPI_CS(unsigned short);
				;29	void _SPI_SCL(unsigned short);
				;30	unsigned char ADXL345_SPI_Read(unsigned char);
				;31	void delay_ms(unsigned char);
				;32	void ADXL345_SPI_Write(unsigned char , unsigned char);
				;33	void LCD_Cmd(unsigned char data);
				;34	void LCD_Senddata(unsigned char data);
				;35	void LCD_Reset(void);
				;36	void PinSet(void);
				;37	void DataFormat(void);
				;38	void PrintLCD(unsigned char);
				;39	unsigned char datax=0, datay=0;
				;40	
				;41	void main()
				;42	{
				@code .SECTION 'CODE'
				include HT66F70A.inc
0000	1F0B	clr     BP
0001	2802	jmp     begin_startup_value
				end_startup_value:
				@start .SECTION 'CODE'
0022	0F00	mov     a, 0H
0023	008B	mov     BP, a
0024	29B8	jmp     _main
0025	0000	nop
0026	0000	nop
0027	0000	nop
0028	0000	nop
				L0029:
0029	0000	nop
				L002A:
002A	0000	nop
002B	1785	sdz     ACC
002C	282A	jmp     L002A
				L002D:
002D	0000	nop
002E	1785	sdz     ACC
002F	282D	jmp     L002D
0030	5783	sdz     bLevel
0031	282D	jmp     L002D
0032	0003	ret
				;43		PinSet();	//腳位設定
				_main:
				_main:
01B8	2197	call    _PinSet
				;44		delay_ms(2);
01B9	0F02	mov     a, 2H
01BA	2033	call    _delay_ms
				;45		DataFormat();	//3軸資料格式設定
01BB	218A	call    _DataFormat
				;46		
				;47		LCD_Reset();		//LCD重置
01BC	2129	call    _LCD_Reset
				;48		delay_ms(250);		//延遲20毫秒 				
01BD	0FFA	mov     a, FAH
01BE	2033	call    _delay_ms
				;49		LCD_Cmd(0xc0);  	//LCD第一行顯示
01BF	0FC0	mov     a, C0H
01C0	211E	call    _LCD_Cmd
				;50		delay_ms(250);            
01C1	0FFA	mov     a, FAH
				_L30:
01C2	2033	call    _delay_ms
				;51		
				;52		while(1)
				;53		{
				;54			datax = ADXL345_SPI_Read(0x2C);
01C3	0F2C	mov     a, 2CH
01C4	20C9	call    _ADXL345_SPI_Read
01C5	4080	mov     ra, a
01C6	4700	mov     a, ra
01C7	408B	mov     datax[0], a
				;55			Delay100us(100);
01C8	0F64	mov     a, 64H
01C9	4083	mov     bLevel, a
01CA	5F04	clr     del
01CB	209F	call    _Delay100us
				;56		
				;57			LCD_Cmd(0x80);  //從第一行第0位置開始顯示   C0為第二行
01CC	0F80	mov     a, 80H
01CD	211E	call    _LCD_Cmd
				;58			delay_ms(150);
01CE	0F96	mov     a, 96H
01CF	2033	call    _delay_ms
				;59		 	PrintLCD(datax);
01D0	470B	mov     a, datax[0]
01D1	2068	call    _PrintLCD
				;60		  		
				;61		  	//delay_ms(1250);
				;62		  	
				;63		  	datay = ADXL345_SPI_Read(0x30);
01D2	0F30	mov     a, 30H
01D3	20C9	call    _ADXL345_SPI_Read
01D4	4080	mov     ra, a
01D5	4700	mov     a, ra
01D6	408A	mov     datay[0], a
				;64		  	Delay100us(100);
01D7	0F64	mov     a, 64H
01D8	4083	mov     bLevel, a
01D9	5F04	clr     del
01DA	209F	call    _Delay100us
				;65		  	LCD_Cmd(0x85);	//從第一行第5位置開始顯示
01DB	0F85	mov     a, 85H
01DC	211E	call    _LCD_Cmd
				;66		 	delay_ms(150);
01DD	0F96	mov     a, 96H
01DE	2033	call    _delay_ms
				;67		  	PrintLCD(datay);
01DF	470A	mov     a, datay[0]
01E0	2068	call    _PrintLCD
				;68			delay_ms(50);	  		
01E1	0F32	mov     a, 32H
01E2	29C2	jmp     _L30
01E3	29E3	jmp     $
				startup_value:
				@ROMDATA_BASE .SECTION 'CODE'
01E4	0002	halt
01E5	008A	mov     STATUS, a
				;69		}
				;70		
				;71	}
				;72	
				;73	//////////////////////////////
				;74	///腳位設定涵式
				;75	//////////////////////////////
				;76	void PinSet(void)
				;77	{
				;78		_wdtc = 0xa8;//關閉看門狗
				_PinSet:
				_PinSet:
0197	0FA8	mov     a, A8H
0198	00BE	mov     WDTC, a
				;79		_cp0c = 0x00;	//類比比較器功能關閉
0199	1F46	clr     CP0C
				;80		_cp1c = 0x00;
019A	1F47	clr     CP1C
				;81		_scomen = 0;
019B	367F	clr     SCOMEN
				;82		_smod = 0xe0;//4MHz
019C	0FE0	mov     a, E0H
019D	00BA	mov     SMOD, a
				;83		_sdis0=0;
019E	B64C	lclr    SDIS0
				;84		_sdis1=0;
01A0	B6CC	lclr    SDIS1
				;85		_simen=1;  
01A2	30EC	set     SIMEN
				;86		_simc0=0x42;
01A3	0F42	mov     a, 42H
01A4	00EC	mov     SIMC0, a
				;87		_simc2=0x24;
01A5	0F24	mov     a, 24H
01A6	00EF	mov     SIMC2, a
				;88		
				;89		//PAS2=0x10;  //設定各個腳位功能
				;90		//PAS3=0x22;  
				;91		//PBS2=0x10;
				;92	
				;93		
				;94		_ifs4=0;
01A7	9F4C	lclr    IFS4
				;95		
				;96		_pac5=0; 	_pac6=1; 	_pac7=0;		CSC=0;//設定I/O
01A9	3693	clr     PAC5
01AA	3313	set     PAC6
01AB	3793	clr     PAC7
01AC	3697	clr     PBC5
				;97		_phc0 = 0; _phc1 = 0; _phc2 = 0; //設置PH0、PH1、PH2為輸出   
01AD	342F	clr     PHC0
01AE	34AF	clr     PHC1
01AF	352F	clr     PHC2
				;98		SDAPU=1;	SDOPU=1;	SCKPU=1;	CSPU=1;		SCK=0;		CS=1;		_pgc = 0x00;   
01B0	3311	set     PAPU6
01B1	3291	set     PAPU5
01B2	3391	set     PAPU7
01B3	3295	set     PBPU5
01B4	3792	clr     PA7
01B5	3296	set     PB5
01B6	1F2B	clr     PGC
01B7	0003	ret
				;99	}
				;100	
				;101	
				;102	//////////////////////////////
				;103	///SPI讀取涵式
				;104	//////////////////////////////
				;105	unsigned char ADXL345_SPI_Read(unsigned char Address)
				;106	{
				_ADXL345_SPI_Read:
				_ADXL345_SPI_Read:
00C9	4085	mov     Address[0], a
				;107	  unsigned char ReadData=0;
00FC	5F09	clr     ReadData[0]
				;108	  unsigned char tempSDO=0;
				;109	  char i;
				;110	 
				;111	  _SPI_CS(0);
00CA	5F03	clr     bLevel
00CB	5F04	clr     del
00CC	20BD	call    __SPI_CS
				;112	  GCC_NOP();
00CD	0000	nop
00CE	0F08	mov     a, 8H
00CF	4086	mov     Address, a
				;113	  
				;114	  for(i = 7; i >= 0; i-- )
00D0	0F07	mov     a, 7H
00D1	4087	mov     Address[1], a
00F1	5587	dec     Address[1]
00F2	5786	sdz     Address
00F3	28D2	jmp     L00D2
				;115	  {
				;116	    // F-Edge
				;117	    _SPI_SCL(1);
				L00D2:
00D2	0F01	mov     a, 1H
00D3	4083	mov     bLevel, a
00D4	5F04	clr     del
00D5	20B3	call    __SPI_SCL
				;118	    SDO = 0x1 & ((0x80 | Address) >> i);
00D6	4705	mov     a, Address[0]
00D7	4081	mov     rb, a
00D8	7381	set     rb.7
00D9	5F02	clr     rc
00DA	5407	inca    Address[1]
00DB	28E1	jmp     L00E1
				L00DC:
00DC	340A	clr     C
00DD	7F82	sz      rc.7
00DE	300A	set     C
00DF	5B82	rrc     rc
00E0	5B81	rrc     rb
				L00E1:
00E1	1785	sdz     ACC
00E2	28DC	jmp     L00DC
00E3	0F01	mov     a, 1H
00E4	4681	andm    a, rb
00E5	5101	swapa   rb
00E6	1885	rl      ACC
00E7	0EE0	and     a, E0H
00E8	4081	mov     rb, a
00E9	3692	clr     PA5
00EA	4701	mov     a, rb
00EB	0592	orm     a, PA
				;119	    GCC_NOP();
00EC	0000	nop
				;120	    _SPI_SCL(0);
00ED	5F03	clr     bLevel
00EE	5F04	clr     del
00EF	20B3	call    __SPI_SCL
				;121	    GCC_NOP();
00F0	0000	nop
				;122	  }
				;123	 
				;124	  //===========================
				;125	  _SPI_SCL(1);
00F4	0F01	mov     a, 1H
00F5	4083	mov     bLevel, a
00F6	5F04	clr     del
00F7	20B3	call    __SPI_SCL
00F8	0F08	mov     a, 8H
00F9	4086	mov     Address, a
				;126	  //===========================
				;127	 
				;128	  for(i = 7; i >= 0; i-- )
00FA	0F07	mov     a, 7H
00FB	4087	mov     Address[1], a
0114	5587	dec     Address[1]
0115	5786	sdz     Address
0116	28FD	jmp     L00FD
				;129	  {
				;130	    // R-Edge
				;131	    _SPI_SCL(0);
				L00FD:
00FD	5F03	clr     bLevel
00FE	5F04	clr     del
00FF	20B3	call    __SPI_SCL
				;132	    _SPI_SCL(1);
0100	0F01	mov     a, 1H
0101	4083	mov     bLevel, a
0102	5F04	clr     del
0103	20B3	call    __SPI_SCL
				;133	    tempSDO = SDA; // Read bit
0104	5F01	clr     rb
0105	3F12	sz      PA6
0106	5481	inc     rb
				;134	 
				;135	    ReadData |= tempSDO << i;
0107	5F02	clr     rc
0108	5407	inca    Address[1]
0109	290D	jmp     L010D
				L010A:
010A	340A	clr     C
010B	5A81	rlc     rb
010C	5A82	rlc     rc
				L010D:
010D	1785	sdz     ACC
010E	290A	jmp     L010A
010F	4709	mov     a, ReadData[0]
0110	4501	or      a, rb
0111	4088	mov     data, a
0112	4708	mov     a, data
0113	4089	mov     ReadData[0], a
				;136	    
				;137	  }
				;138	  GCC_NOP();
0117	0000	nop
				;139	  _SPI_CS(1);
0118	0F01	mov     a, 1H
0119	4083	mov     bLevel, a
011A	5F04	clr     del
011B	20BD	call    __SPI_CS
				;140	  return ReadData & 0xFF;
				;141	}
011C	4708	mov     a, data
011D	0003	ret
				;142	
				;143	//////////////////////////////
				;144	///資料格式涵式
				;145	//////////////////////////////
				;146	void DataFormat(void)
				;147	{
				;148		ADXL345_SPI_Write(0x31, 0x0B); //設定測量範圍&資料格式
				_DataFormat:
				_DataFormat:
018A	0F0B	mov     a, BH
018B	4085	mov     data, a
018C	0F31	mov     a, 31H
018D	2134	call    _ADXL345_SPI_Write
				;149		ADXL345_SPI_Write(0x2D, 0x08); //開始測量
018E	0F08	mov     a, 8H
018F	4085	mov     data, a
0190	0F2D	mov     a, 2DH
0191	2134	call    _ADXL345_SPI_Write
				;150		ADXL345_SPI_Write(0x2E, 0x80);
0192	0F80	mov     a, 80H
0193	4085	mov     data, a
0194	0F2E	mov     a, 2EH
0195	2134	call    _ADXL345_SPI_Write
0196	0003	ret
				;151	}
				;152	
				;153	//////////////////////////////
				;154	///LCD顯示涵式
				;155	//////////////////////////////
				;156	void PrintLCD(unsigned char data)
				;157	{
				_PrintLCD:
				_PrintLCD:
0068	4080	mov     ra, a
0069	4088	mov     data[0], a
				;158		
				;159		LCD_Senddata((data/100)%10+0x30); 
006A	5F06	clr     Address
006B	4700	mov     a, ra
006C	4083	mov     bLevel, a
006D	0F64	mov     a, 64H
006E	4084	mov     del, a
006F	204F	call    L004F
0070	4703	mov     a, bLevel
0071	4080	mov     ra, a
0072	5F06	clr     Address
0073	4700	mov     a, ra
0074	4083	mov     bLevel, a
0075	0F0A	mov     a, AH
0076	4084	mov     del, a
0077	204F	call    L004F
0078	4705	mov     a, data
0079	4080	mov     ra, a
007A	0F30	mov     a, 30H
007B	4380	addm    a, ra
007C	4700	mov     a, ra
007D	2044	call    _LCD_Senddata
				;160		LCD_Senddata((data/10)%10+0x30);
007E	5F06	clr     Address
007F	4708	mov     a, data[0]
0080	4083	mov     bLevel, a
0081	0F0A	mov     a, AH
0082	4084	mov     del, a
0083	204F	call    L004F
0084	4703	mov     a, bLevel
0085	4080	mov     ra, a
0086	5F06	clr     Address
0087	4700	mov     a, ra
0088	4083	mov     bLevel, a
0089	0F0A	mov     a, AH
008A	4084	mov     del, a
008B	204F	call    L004F
008C	4705	mov     a, data
008D	4080	mov     ra, a
008E	0F30	mov     a, 30H
008F	4380	addm    a, ra
0090	4700	mov     a, ra
0091	2044	call    _LCD_Senddata
				;161		LCD_Senddata((data/1)%10+0x30);
0092	5F06	clr     Address
0093	4708	mov     a, data[0]
0094	4083	mov     bLevel, a
0095	0F0A	mov     a, AH
0096	4084	mov     del, a
0097	204F	call    L004F
0098	4705	mov     a, data
0099	4080	mov     ra, a
009A	0F30	mov     a, 30H
009B	4380	addm    a, ra
009C	4700	mov     a, ra
009D	2044	call    _LCD_Senddata
009E	0003	ret
				;162	}
				;163	
				;164	//////////////////////////////
				;165	///Delay100us涵式
				;166	//////////////////////////////
				;167	void Delay100us(short del)						//延遲del*200指令週期
				;168	{	short i,j;									//@fSYS=8MH,延遲del*100us
				;169		for(i=0;i<del;i++)
				_Delay100us:
				_Delay100us:
009F	5F01	clr     rb
00A0	5F02	clr     rc
				_L3:
00A1	4701	mov     a, rb
00A2	4203	sub     a, del[0]
00A3	4702	mov     a, rc
00A4	5204	sbc     a, del[1]
00A5	3B8A	snz     SC
00A6	28B2	jmp     _L2
00A7	5F00	clr     ra
00AE	5481	inc     rb
00AF	3D0A	sz      Z
00B0	5482	inc     rc
00B1	28A1	jmp     _L3
				_L2:
00B2	0003	ret
				;170			for(j=0;j<=25;j++) GCC_NOP();
				_L6:
00A8	0000	nop
00A9	5480	inc     ra
00AA	4700	mov     a, ra
00AB	0A1A	sub     a, 1AH
00AC	390A	snz     Z
00AD	28A8	jmp     _L6
				;171	}	
				;172	
				;173	//////////////////////////////
				;174	///CS腳電位涵式
				;175	//////////////////////////////
				;176	void _SPI_CS(unsigned short isSelect)
				;177	{
				;178	    CS=isSelect;
				__SPI_CS:
				__SPI_CS:
00BD	4703	mov     a, isSelect[0]
00BE	0E01	and     a, 1H
00BF	4080	mov     ra, a
00C0	5100	swapa   ra
00C1	1885	rl      ACC
00C2	0EE0	and     a, E0H
00C3	4080	mov     ra, a
00C4	3696	clr     PB5
00C5	4700	mov     a, ra
00C6	0596	orm     a, PB
				;179	    GCC_NOP();
00C7	0000	nop
00C8	0003	ret
				;180	}
				;181	
				;182	//////////////////////////////
				;183	///SCL腳電位涵式
				;184	//////////////////////////////
				;185	void _SPI_SCL(unsigned short bLevel)
				;186	{
				;187	    SCK=bLevel;
				__SPI_SCL:
				__SPI_SCL:
00B3	4703	mov     a, bLevel[0]
00B4	4080	mov     ra, a
00B5	5B80	rrc     ra
00B6	5F00	clr     ra
00B7	5B80	rrc     ra
00B8	3792	clr     PA7
00B9	4700	mov     a, ra
00BA	0592	orm     a, PA
				;188	    GCC_NOP();
00BB	0000	nop
00BC	0003	ret
				;189	}
				;190	
				;191	//////////////////////////////
				;192	///SPI寫入涵式
				;193	//////////////////////////////
				;194	void ADXL345_SPI_Write(unsigned char Address, unsigned char WriteData)
				;195	{
				_ADXL345_SPI_Write:
				_ADXL345_SPI_Write:
0134	4086	mov     Address[0], a
				;196	  char i;
				;197	 
				;198	  _SPI_CS(0);
0135	5F03	clr     bLevel
0136	5F04	clr     del
0137	20BD	call    __SPI_CS
				;199	  GCC_NOP();
0138	0000	nop
0139	0F08	mov     a, 8H
013A	4087	mov     Address[1], a
				;200	 
				;201	  for(i=7; i >= 0; i--)
013B	0F07	mov     a, 7H
013C	4088	mov     data, a
015C	5588	dec     data
015D	5787	sdz     Address[1]
015E	293D	jmp     L013D
015F	0F08	mov     a, 8H
0160	4087	mov     Address[1], a
0161	0F07	mov     a, 7H
0162	4088	mov     data, a
				;202	  {
				;203	    // F-Edge
				;204	    _SPI_SCL(1);
				L013D:
013D	0F01	mov     a, 1H
013E	4083	mov     bLevel, a
013F	5F04	clr     del
0140	20B3	call    __SPI_SCL
				;205	    SDO = 0x01 & ((0x7F & Address) >> i);
0141	4706	mov     a, Address[0]
0142	4081	mov     rb, a
0143	7781	clr     rb.7
0144	5F02	clr     rc
0145	5408	inca    data
0146	294C	jmp     L014C
				L0147:
0147	340A	clr     C
0148	7F82	sz      rc.7
0149	300A	set     C
014A	5B82	rrc     rc
014B	5B81	rrc     rb
				L014C:
014C	1785	sdz     ACC
014D	2947	jmp     L0147
014E	0F01	mov     a, 1H
014F	4681	andm    a, rb
0150	5101	swapa   rb
0151	1885	rl      ACC
0152	0EE0	and     a, E0H
0153	4081	mov     rb, a
0154	3692	clr     PA5
0155	4701	mov     a, rb
0156	0592	orm     a, PA
				;206	    GCC_NOP();
0157	0000	nop
				;207	    _SPI_SCL(0);
0158	5F03	clr     bLevel
0159	5F04	clr     del
015A	20B3	call    __SPI_SCL
				;208	    GCC_NOP();
015B	0000	nop
				;209	  }
				;210	 
				;211	  for(i=7; i >= 0; i--)
0181	5588	dec     data
0182	5787	sdz     Address[1]
0183	2963	jmp     L0163
				;212	  {
				;213	    // F-Edge
				;214	    _SPI_SCL(1);
				L0163:
0163	0F01	mov     a, 1H
0164	4083	mov     bLevel, a
0165	5F04	clr     del
0166	20B3	call    __SPI_SCL
				;215	    SDO = 0x1 & ((WriteData) >> i);
0167	4705	mov     a, WriteData[0]
0168	4081	mov     rb, a
0169	5F02	clr     rc
016A	5408	inca    data
016B	2971	jmp     L0171
				L016C:
016C	340A	clr     C
016D	7F82	sz      rc.7
016E	300A	set     C
016F	5B82	rrc     rc
0170	5B81	rrc     rb
				L0171:
0171	1785	sdz     ACC
0172	296C	jmp     L016C
0173	0F01	mov     a, 1H
0174	4681	andm    a, rb
0175	5101	swapa   rb
0176	1885	rl      ACC
0177	0EE0	and     a, E0H
0178	4081	mov     rb, a
0179	3692	clr     PA5
017A	4701	mov     a, rb
017B	0592	orm     a, PA
				;216	    GCC_NOP();
017C	0000	nop
				;217	    _SPI_SCL(0);
017D	5F03	clr     bLevel
017E	5F04	clr     del
017F	20B3	call    __SPI_SCL
				;218	    GCC_NOP();
0180	0000	nop
				;219	  }
				;220	 GCC_NOP();
0184	0000	nop
				;221	  _SPI_CS(1);
0185	0F01	mov     a, 1H
0186	4083	mov     bLevel, a
0187	5F04	clr     del
0188	20BD	call    __SPI_CS
0189	0003	ret
				;222	}
				;223	
				;224	//---傳送命令到LCD
				;225	void LCD_Cmd(unsigned char data)
				;226	{
				_LCD_Cmd:
				_LCD_Cmd:
011E	4080	mov     ra, a
011F	4085	mov     data[0], a
				;227	    DATA_BUS = data;  //命令送到BUS
0120	4700	mov     a, ra
0121	00AA	mov     PG, a
				;228	    RS=0; RW=0; EN=1; //命令到LCD內 
0122	342E	clr     PH0
0123	34AE	clr     PH1
0124	312E	set     PH2
				;229	    delay_ms(1);
0125	0F01	mov     a, 1H
0126	2033	call    _delay_ms
				;230	    EN=0;           //禁能LCD
0127	352E	clr     PH2
0128	0003	ret
				;231	}
				;232	//---傳送資料到LCD 
				;233	void LCD_Senddata(unsigned char data)
				;234	{
				_LCD_Senddata:
				_LCD_Senddata:
0044	4080	mov     ra, a
0045	4085	mov     data[0], a
				;235	    DATA_BUS = data;  //資料送到BUS
0046	4700	mov     a, ra
0047	00AA	mov     PG, a
				;236	    RS=1; RW=0; EN=1; //資料到LCD內
0048	302E	set     PH0
0049	34AE	clr     PH1
004A	312E	set     PH2
				;237	    delay_ms(1);
004B	0F01	mov     a, 1H
004C	2033	call    _delay_ms
				;238	    EN=0;           //禁能LCD
004D	352E	clr     PH2
004E	0003	ret
				L004F:
004F	5F05	clr     data[0]
0050	0F08	mov     a, 8H
0051	4087	mov     Address[1], a
				L0052:
0052	340A	clr     C
0053	5A83	rlc     bLevel
0054	5A85	rlc     data[0]
0055	4705	mov     a, data[0]
0056	4204	sub     a, del
0057	380A	snz     C
0058	285D	jmp     L005D
0059	4705	mov     a, data[0]
005A	4204	sub     a, del
005B	4085	mov     data[0], a
005C	5483	inc     bLevel
				L005D:
005D	5787	sdz     Address[1]
005E	2852	jmp     L0052
005F	7C06	sz      Address.0
0060	4185	cpl     data[0]
0061	7C06	sz      Address.0
0062	5485	inc     data[0]
0063	7C86	sz      Address.1
0064	4183	cpl     bLevel
0065	7C86	sz      Address.1
0066	5483	inc     bLevel
0067	0003	ret
				;239	}
				;240	//---LCD的啟始程式  
				;241	void LCD_Reset(void)
				;242	{
				;243	    LCD_Cmd(0b00111000);//8bit傳輸,顯示2行,5*7字型
				_LCD_Reset:
				_LCD_Reset:
0129	0F38	mov     a, 38H
012A	211E	call    _LCD_Cmd
				;244	                        //bit4:DL=1,8bit傳輸,
				;245	                        //bit3:N=1,顯示2行
				;246	                        //bit2:F=0,5*7字型                        
				;247	    LCD_Cmd(0b00001100);//顯示幕ON,不顯示游標,游標不閃爍
012B	0F0C	mov     a, CH
012C	211E	call    _LCD_Cmd
				;248	                        //bit2:D=1,顯示幕ON
				;249	                        //bit1:C=0,不顯示游標                      
				;250	    LCD_Cmd(0b00000110);//顯示完游標右移,游標移位禁能 
012D	0F06	mov     a, 6H
012E	211E	call    _LCD_Cmd
				;251	                        //bit1:I/D=1,顯示完游標右移
				;252	                        //bit0:S=0,游標移位禁能                                   
				;253	    LCD_Cmd(0b00000001); //清除顯示幕
012F	0F01	mov     a, 1H
0130	211E	call    _LCD_Cmd
				;254	    LCD_Cmd(0b00000010); //游標回原位 
0131	0F02	mov     a, 2H
0132	211E	call    _LCD_Cmd
0133	0003	ret
				;255	}
				;256	
				;257	//////////////////////////////
				;258	///Delay毫秒涵式
				;259	//////////////////////////////
				;260	void delay_ms(unsigned char del)
				;261	{	
				_delay_ms:
				_delay_ms:
0033	4084	mov     del[0], a
				;262		unsigned char i;
				;263		for(i=0;i<del;i++) GCC_DELAY(2000);		//內建函式，延遲2000指令週期
0034	5F00	clr     ra
0035	283F	jmp     L003F
				L0036:
0036	0F01	mov     a, 1H
0037	4083	mov     bLevel, a
0038	0FF1	mov     a, F1H
0039	340B	clr     BP0
003A	348B	clr     BP1
003B	2029	call    L0029
003C	340B	clr     BP0
003D	348B	clr     BP1
003E	5480	inc     ra
				L003F:
003F	4700	mov     a, ra
0040	4204	sub     a, del[0]
0041	390A	snz     Z
0042	2836	jmp     L0036
0043	0003	ret
				;264	}
				;file D:\IIIT\Documents\HTK_Project\Triaxial_sensor\startup1_l.asm
				;1	;;--------------------------------------------------------------;;
				;2	;;    This file is part of the Holtek C Compiler V3 package     ;;
				;3	;;    For the initialization of static linkage variables        ;;
				;4	;;    Copyright (C) 2013 Holtek Semiconductor Inc.              ;;
				;5	;;    Version: 1.04 (Above IDE3000 V7.72)                       ;;
				;6	;;    Date:    2013/12/04                                        ;;
				;7	;;--------------------------------------------------------------;;
				;8	
				;9	acc equ [05h]
				;10	tblp equ [07h]
				;11	tblh equ [08h]
				;12	;;tbhp equ [09h] 
				;13	mp0 equ [01h]
				;14	r1 equ [02h]
				;15	mp1l equ [03h]
				;16	mp1h equ [04h]
				;17	z equ [0ah].2
				;18	c equ [0ah].0
				;19	
				;20	ifndef tbhp
				;21	tbhp equ [09h]
				;22	endif
				;23	 
				;24	extern startup_value_1:near
				;25	
				;26	@start .section 'code'
				;27	begin_startup_value:
				;28	  mov a,low (offset startup_value_1) 
				begin_startup_value:
				@start .SECTION 'CODE'
				_main_startup1:
				@start .SECTION 'CODE'
0002	0FE3	mov     a, E3H
				;29	  mov tblp,a
0003	0087	mov     TBLP, a
				;30	  mov a,high (offset startup_value_1) 
0004	0F01	mov     a, 1H
				;31	  mov tbhp,a
0005	0089	mov     TBHP, a
				;32	next_table:
				;33	  ;CLR WDT
				;34	  inc tblp
				next_table:
0006	1487	inc     TBLP
				;35	  sz z
0007	3D0A	sz      Z
				;36	  inc tbhp
0008	1489	inc     TBHP
				;37	  tabrdc mp0
0009	1D01	tabrd   MP0
				;38	  sz mp0
000A	1081	sz      MP0
				;39	  jmp read_data
000B	280D	jmp     read_data
				;40	  jmp end_startup_value
000C	2822	jmp     end_startup_value
				;41	read_data:
				;42	  inc tblp
				read_data:
000D	1487	inc     TBLP
				;43	  sz z
000E	3D0A	sz      Z
				;44	  inc tbhp
000F	1489	inc     TBHP
				;45	  tabrdc mp1l
0010	1D03	tabrd   MP1L
				;46	  mov a,tblh
0011	0708	mov     a, TBLH
				;47	  mov mp1h,a
0012	0084	mov     MP1H, a
				;48	next_data:
				;49	  inc tblp
				next_data:
0013	1487	inc     TBLP
				;50	  sz z
0014	3D0A	sz      Z
				;51	  inc tbhp
0015	1489	inc     TBHP
				;52	  tabrdc acc
0016	1D05	tabrd   ACC
				;53	  mov r1,a
0017	0082	mov     [02H], a
				;54	  sdz mp0
0018	1781	sdz     MP0
				;55	  jmp $+2
0019	281B	jmp     L001B
				;56	  jmp next_table
001A	2806	jmp     next_table
				;57	  inc mp1l
				L001B:
001B	1483	inc     MP1L
				;58	  mov a,tblh
001C	0708	mov     a, TBLH
				;59	  mov r1,a
001D	0082	mov     [02H], a
				;60	  inc mp1l
001E	1483	inc     MP1L
				;61	  sdz mp0
001F	1781	sdz     MP0
				;62	  jmp next_data
0020	2813	jmp     next_data
				;63	  jmp next_table
0021	2806	jmp     next_table
				;64	
				;65	end_startup_value:
				;66	
				;67	   
				;68	@ROMDATA_BASE .SECTION com_l 'CODE'  
				;69	startup_value:
				;70	;;linker range the initial value table here
				data .SECTION 'DATA'
				__papu DB DUP (?) ; __papu
				__pa DB DUP (?) ; __pa
				__pac DB DUP (?) ; __pac
				__pbpu DB DUP (?) ; __pbpu
				__pb DB DUP (?) ; __pb
				__pbc DB DUP (?) ; __pbc
				__pg DB DUP (?) ; __pg
				__pgc DB DUP (?) ; __pgc
				__ph DB DUP (?) ; __ph
				__phc DB DUP (?) ; __phc
				__smod DB DUP (?) ; __smod
				__wdtc DB DUP (?) ; __wdtc
				__cp0c DB DUP (?) ; __cp0c
				__cp1c DB DUP (?) ; __cp1c
				__simc0 DB DUP (?) ; __simc0
				__simc2 DB DUP (?) ; __simc2
				__scomc DB DUP (?) ; __scomc
				ra DB DUP (?)
				rb DB DUP (?)
				rc DB DUP (?)
				bLevel DB 2 DUP (?) ; bLevel
				del DB DUP (?) ; del
				data DB DUP (?) ; data
				Address DB DUP (?) ; Address
				data DB DUP (?) ; data
				ReadData DB DUP (?) ; ReadData
				datay DB DUP (?) ; datay
				datax DB DUP (?) ; datax
				__ifs4 DB DUP (?) ; __ifs4
